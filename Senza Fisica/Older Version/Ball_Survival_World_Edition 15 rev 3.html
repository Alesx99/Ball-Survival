<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Ball Survival - World Edition 3.2 (Corretto)</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%; background: #000;
            display: flex; justify-content: center; align-items: center;
            font-family: 'Courier New', monospace; color: white; overflow: hidden;
        }
        #gameContainer {
            position: relative; width: 100%; max-width: 1000px; aspect-ratio: 4 / 3;
            background: #000; border: 3px solid #0f3460; border-radius: 10px;
            overflow: hidden; touch-action: none;
        }
        #gameCanvas { display: block; width: 100%; height: 100%; }
        #menuOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); z-index: 199; display: none;
        }
        #ui {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            font-size: clamp(10px, 2vw, 16px); text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px;
        }
        #gemsDisplay { margin-top: 5px; color: #72f5f5; font-weight: bold; }

        .popup-menu {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, rgba(15,52,96,0.95) 0%, rgba(10,30,50,0.95) 100%);
            border-radius: 15px; padding: clamp(15px, 4vw, 30px); z-index: 200;
            text-align: center; border: 2px solid #4a90e2;
            display: none;
            width: 90%; max-width: 600px;
            box-sizing: border-box;
            flex-direction: column; max-height: 90vh;
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.5);
        }

        #gameOver { border-color: #e74c3c; box-shadow: 0 0 25px rgba(231, 76, 60, 0.5); }
        #permanentUpgradeShop { border-color: #f1c40f; box-shadow: 0 0 25px rgba(241, 196, 15, 0.5); }
        #pauseMenu h2, #permanentUpgradeShop h3, #upgradeMenu h3, #startScreen h2 { margin-top: 0; color: #f1c40f; text-transform: uppercase; letter-spacing: 2px; }
        #pauseStatsContainer { display: flex; flex-direction: row; gap: 20px; overflow-y: auto; flex-grow: 1; margin: 15px 0; padding: 5px; text-align: left; }
        .stats-column { flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 15px; }
        .stats-section { background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border-left: 3px solid #f1c40f; }
        .stats-section-title { font-weight: bold; color: #5dade2; margin-bottom: 10px; font-size: clamp(15px, 2.5vw, 18px); border-bottom: 1px solid rgba(74, 144, 226, 0.5); padding-bottom: 5px; }
        #permanentUpgradeOptions, #upgradeOptions { overflow-y: auto; flex-grow: 1; margin: 15px 0; padding-right: 10px; min-height: 50px; text-align: left; }
        .permanent-upgrade-option { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 10px; background: #2c3e50; border: 1px solid #4a90e2; margin: 10px 0; padding: 15px; border-radius: 5px; text-align: left; }
        .upgrade-option { background: #2c3e50; border: 1px solid #4a90e2; margin: 5px 0; padding: 15px; border-radius: 5px; cursor: pointer; transition: all 0.3s; text-align: left; }
        .upgrade-option:hover { background: #34495e; border-color: #5dade2; transform: scale(1.02); }
        .upgrade-option.evolution { border-color: #f1c40f; }
        .upgrade-title, .stat-item-title { font-size: clamp(14px, 2.5vw, 16px); font-weight: bold; color: #5dade2; }
        .evolution .upgrade-title { color: #f1c40f; }
        .perm-upgrade-cost { font-size: clamp(12px, 2vw, 14px); color: #f1c40f; }
        .perm-upgrade-level { font-size: clamp(10px, 1.8vw, 12px); color: #bdc3c7; }
        .upgrade-desc { font-size: clamp(10px, 1.8vw, 12px); color: #bdc3c7; margin-top: 5px; }
        .stat-item { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; font-size: clamp(12px, 2vw, 14px); }
        .stat-item .icon { width: 20px; height: 20px; fill: #f1c40f; flex-shrink: 0; }
        .stat-item-label { color: #ecf0f1; }
        .stat-item-value { color: #bdc3c7; font-weight: bold; }
        .weapon-stat-details { font-size: clamp(10px, 1.8vw, 12px); color: #bdc3c7; margin-left: 28px; }
        button {
            background: #4a90e2; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;
            font-size: clamp(12px, 2.2vw, 14px); margin: 5px; transition: background 0.3s;
            -webkit-tap-highlight-color: transparent; flex-shrink: 0;
        }
        button:hover { background: #5dade2; }
        button:disabled { background: #566573; cursor: not-allowed; }
        .buy-button { background: #27ae60; }
        .buy-button:hover { background: #2ecc71; }
        .controls { margin-top: 20px; font-size: clamp(10px, 1.8vw, 12px); color: #bdc3c7; }
        #joystick-container { position: fixed; width: 120px; height: 120px; background: rgba(128, 128, 128, 0.4); border-radius: 50%; z-index: 150; display: none; pointer-events: none; }
        #joystick-stick { position: absolute; top: 30px; left: 30px; width: 60px; height: 60px; background: rgba(200, 200, 200, 0.6); border-radius: 50%; }
        #pauseButton { position: absolute; top: 15px; right: 15px; width: 40px; height: 40px; background: rgba(255, 255, 255, 0.15); color: white; border: 2px solid rgba(255, 255, 255, 0.7); border-radius: 50%; display: none; justify-content: center; align-items: center; font-size: 20px; line-height: 20px; font-weight: bold; cursor: pointer; z-index: 150; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="menuOverlay"></div>
        <canvas id="gameCanvas"></canvas>
        <div id="joystick-container"><div id="joystick-stick"></div></div>
        <div id="pauseButton">||</div>

        <div id="ui">
            <div>HP: <span id="hp">100</span>/100</div>
            <div>Livello: <span id="level">1</span></div>
            <div>XP: <span id="xp">0</span>/<span id="xpNext">10</span></div>
            <div>Nemici: <span id="enemies">0</span></div>
            <div>Tempo: <span id="time">0</span>s</div>
            <div>Punteggio: <span id="score">0</span></div>
            <div id="gemsDisplay">
                <div>Cristalli: <span id="totalGemsUI">0</span> ðŸ’Ž</div>
                <div>Raccolti: <span id="runGemsUI">0</span></div>
            </div>
        </div>

        <div id="startScreen" class="popup-menu">
            <h2>âš½ Ball Survival 3.2</h2>
            <p>Sopravvivi il piÃ¹ a lungo possibile!</p>
            <div class="controls">
                <p><strong>Controlli:</strong> Joystick (Mobile), WASD/Frecce (PC), E/Tocca (Negozio), ESC/Pausa</p>
            </div>
            <button id="startGameBtn">Inizia Partita</button>
        </div>
        <div id="upgradeMenu" class="popup-menu">
            <h3>Scegli un Potenziamento!</h3>
            <div id="upgradeOptions"></div>
        </div>
        <div id="pauseMenu" class="popup-menu">
            <h2>Pausa</h2>
            <div id="pauseStatsContainer">
                <div id="playerStatsColumn" class="stats-column"></div>
                <div id="weaponsStatsColumn" class="stats-column"></div>
            </div>
            <button id="restartFromPauseBtn">Riavvia</button>
        </div>
        <div id="gameOver" class="popup-menu">
            <h2>Game Over!</h2>
            <p>Sei sopravvissuto per <span id="survivalTime">0</span> secondi</p>
            <p>Nemici sconfitti: <span id="enemiesKilled">0</span></p>
            <p>Cristalli raccolti: <span id="gemsEarned">0</span></p>
            <p>Punteggio Finale: <span id="finalScore">0</span></p>
            <button id="restartGameBtn">Riprova</button>
        </div>
        <div id="permanentUpgradeShop" class="popup-menu">
            <h3>Negozio Permanente</h3>
            <p>I tuoi cristalli: <span id="totalGemsShop">0</span> ðŸ’Ž</p>
            <div id="permanentUpgradeOptions"></div>
        </div>
    </div>

<script>
// ##################################################################
// ########### REFACTORED & COMPLETE - Ball Survival 3.2 ############
// ##################################################################
const CONFIG = {
    world: { width: 8000, height: 6000, gridSize: 100 },
    player: {
        base: { hp: 100, speed: 3, radius: 15 },
        xpCurve: { base: 8, growth: 1.15, levelFactor: 10, power: 1.0 }
    },
    enemies: {
        spawnInterval: 0.8,
        scaling: { timeFactor: 9, hpPerFactor: 6, speedPerFactor: 0.03, damagePerFactor: 2 },
        base: { hp: 15, speed: 0.8, radius: 12, damage: 6, xp: 2 }
    },
    boss: {
        spawnThreshold: 150,
        base: { hp: 1000, speed: 1.5, radius: 40, damage: 25 },
        scaling: { timeFactor: 60, hpPerFactor: 500 },
        attack: { cooldown: 2000, projectileSpeed: 4, projectileRadius: 8 }
    },
    chest: {
        spawnTime: 20,
        respawnTime: 30,
        size: 25,
        gemDrop: { min: 5, random: 6 }
    },
    merchant: {
        x: 4000, y: 2800, size: 40, interactionRadius: 60
    },
    xpOrbs: {
        mapSpawn: { interval: 4, batch: 15, max: 300, value: 5 },
        pickupRadius: 100
    },
    upgradeTree: {
        'fireball': { id: 'fireball', name: 'Sfera di Fuoco', desc: 'Lancia una palla di fuoco che esplode all\'impatto.', details: "+5 Danni, +5 Raggio Esplosione", maxLevel: 4 },
        'fireball_evolve_giant': { id: 'fireball_evolve_giant', name: 'EVOLUZIONE: Palla di Fuoco Gigante', desc: 'Trasforma l\'abilitÃ  in un\'unica, lenta ma devastante palla di fuoco che trapassa tutti i nemici e lascia una scia ardente.', details: "Danno e raggio massicci. Trapassa i nemici. Lascia fiamme.", type: 'evolution' },
        'fireball_evolve_meteor': { id: 'fireball_evolve_meteor', name: 'EVOLUZIONE: Pioggia di Meteore', desc: 'Trasforma l\'abilitÃ  per far piovere meteore dal cielo sui nemici visibili, infliggendo danni ad area.', details: "Evoca 3 meteore sui nemici.", type: 'evolution' },
        'fireball_giant_mastery': { id: 'fireball_giant_mastery', name: 'Maestria: Palla Gigante', desc: 'Aumenta ulteriormente i danni della Palla di Fuoco Gigante e della sua scia.', details: "+30 Danni, +5 Danni da bruciatura" },
        'fireball_meteor_mastery': { id: 'fireball_meteor_mastery', name: 'Maestria: Pioggia di Meteore', desc: 'Aumenta il numero di meteore e il loro raggio d\'impatto.', details: "+1 Meteora, +10 Raggio d'impatto" },
        'lightning': { id: 'lightning', name: 'Fulmine a Catena', desc: 'Un fulmine che rimbalza tra i nemici vicini.', details: "+4 Danni, +1 Rimbalzo", maxLevel: 8 },
        'frostbolt': { id: 'frostbolt', name: 'Dardo di Gelo', desc: 'Un dardo che trapassa e rallenta i nemici.', details: "+3 Danni, +1 Perforazione", maxLevel: 8 },
        'shotgun': { id: 'shotgun', name: 'Fucile Arcano', desc: 'Una rosa di proiettili a corto raggio.', details: "+2 Danni, +2 Proiettili", maxLevel: 8 },
        'shockwave': { id: 'shockwave', name: 'Onda d\'Urto', desc: 'Respinge e danneggia i nemici circostanti.', details: "+10 Danni, +15 Raggio, +5 Respinta", maxLevel: 8 },
        'heal': { id: 'heal', name: 'Impulso Curativo', desc: 'Emette un impulso che rigenera la salute.', details: "+10 Salute Curata, -1s Ricarica", maxLevel: 5 },
        'shield': { id: 'shield', name: 'Scudo Magico', desc: 'Crea una barriera protettiva temporanea.', details: "+1s Durata, -1.5s Ricarica", maxLevel: 5 },
        'health': { id: 'health', name: 'VitalitÃ ', desc: 'Aumenta la salute massima di 25.', maxLevel: 10, type: 'passive' },
        'speed': { id: 'speed', name: 'RapiditÃ ', desc: 'Aumenta la velocitÃ  di movimento.', maxLevel: 5, type: 'passive' },
        'attack_speed': { id: 'attack_speed', name: 'VelocitÃ  d\'attacco', desc: 'Riduce la ricarica di tutte le abilitÃ .', details: "-8% Ricarica Globale", maxLevel: 5, type: 'passive' }
    },
    permanentUpgrades: {
        health:    { name: "Salute Base",       maxLevel: 10, baseCost: 10, costGrowth: 1.4, effect: (lvl) => `+${lvl * 10} HP` },
        power:     { name: "Potenza Globale",   maxLevel: 10, baseCost: 15, costGrowth: 1.6, effect: (lvl) => `+${lvl * 5}% Danni` },
        frequency: { name: "Frequenza Globale", maxLevel: 10, baseCost: 20, costGrowth: 1.7, effect: (lvl) => `-${lvl * 3}% Ricarica` },
        area:      { name: "Area d'Effetto",    maxLevel: 10, baseCost: 15, costGrowth: 1.6, effect: (lvl) => `+${lvl * 4}% Area` },
        speed:     { name: "VelocitÃ  Base",     maxLevel: 5,  baseCost: 20, costGrowth: 1.8, effect: (lvl) => `+${(lvl * 0.1).toFixed(1)} Vel.` },
        xpGain:    { name: "Guadagno XP",       maxLevel: 10, baseCost: 15, costGrowth: 1.5, effect: (lvl) => `+${lvl * 5}% XP` },
        luck:      { name: "Fortuna",           maxLevel: 10, baseCost: 25, costGrowth: 1.7, effect: (lvl) => `+${lvl * 2}% Drop` }
    },
    itemTypes: {
        'HEAL_POTION': { name: "Pozione di Cura", color: '#ff69b4', desc: "Ripristina il 50% della salute massima." },
        'XP_BOMB': { name: "Bomba di XP", color: '#ffff00', desc: "Fornisce un'enorme quantitÃ  di esperienza." },
        'INVINCIBILITY': { name: "Scudo Divino", color: '#ffffff', desc: "ImmunitÃ  dai danni per 10 secondi." },
        'DAMAGE_BOOST': { name: "Gemma del Potere", color: '#ff4500', desc: "Aumenta i danni del 25% per 20 secondi." },
        'LEGENDARY_ORB': { name: "Frammento Divino", color: '#ff00ff', desc: "InvincibilitÃ  e danni aumentati per 60 secondi!" }
    },
    statIcons: {
        health: `<svg class="icon" viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>`,
        speed: `<svg class="icon" viewBox="0 0 24 24"><path d="M15.58 11.5l-3.5-3.5a1 1 0 00-1.41 1.41L12.17 11H5a1 1 0 000 2h7.17l-1.5 1.5a1 1 0 101.41 1.41l3.5-3.5c.19-.2.3-.45.3-.71s-.11-.51-.3-.71zM19 3a1 1 0 00-1 1v16a1 1 0 002 0V4a1 1 0 00-1-1z"/></svg>`,
        power: `<svg class="icon" viewBox="0 0 24 24"><path d="M12 2L9.19 8.63L2 9.24l5.46 4.73L5.82 21L12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2z"/></svg>`,
        frequency: `<svg class="icon" viewBox="0 0 24 24"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/></svg>`,
        area: `<svg class="icon" viewBox="0 0 24 24"><path d="M3 11h2v2H3v-2zm2-2h2v2H5V9zm2-2h2v2H7V7zM3 3h2v2H3V3zm16 0h2v2h-2V3zm0 4h2v2h-2V7zm0 4h2v2h-2v-2zm0 4h2v2h-2v-2zm-4 4h2v2h-2v-2zM7 17h2v2H7v-2zm-2 2h2v2H5v-2zm-2-4h2v2H3v-2zm16-4h2v2h-2v-2zM15 5h2v2h-2V5zm-4 0h2v2h-2V5zm-4 0h2v2H7V5zM5 5h2v2H5V5zm8 12h2v2h-2v-2zm-4 0h2v2H9v-2zm-4 0h2v2H5v-2z"/></svg>`,
        luck: `<svg class="icon" viewBox="0 0 24 24"><path d="M16.29 5.71a1 1 0 00-1.41 0L12 8.59l-2.88-2.88a1 1 0 00-1.41 1.41L10.59 10l-2.88 2.88a1 1 0 101.41 1.41L12 11.41l2.88 2.88a1 1 0 001.41-1.41L13.41 10l2.88-2.88a1 1 0 000-1.41zM12 2a10 10 0 100 20 10 10 0 000-20z"/></svg>`,
        xpGain: `<svg class="icon" viewBox="0 0 24 24"><path d="M12 1L9 4h6l-3-3zm0 22l3-3H9l3 3zm7-11h-3v-2h3v2zm-4 2h-2v2h2v-2zm-2-4V8h-2v2h2zm-4 0V8H7v2h2zm-2 4h-2v2h2v-2zM7 8V6H5v2h2zm12-4h-2v2h2V4zm-2 14h-2v2h2v-2zm-4 0h-2v2h2v-2zm-4 0H7v2h2v-2zm-4-4H3v2h2v-2z"/></svg>`,
    }
};
const Utils = {
    getDistance: (obj1, obj2) => {
        const dx = obj1.x - obj2.x; const dy = obj1.y - obj2.y;
        return Math.sqrt(dx * dx + dy * dy);
    },
    findNearest: (from, targets, range = Infinity) => {
        let nearest = null; let minDist = range;
        for (const target of targets) {
            if (target.toRemove) continue;
            const dist = Utils.getDistance(from, target);
            if (dist < minDist) { minDist = dist; nearest = target; }
        }
        return nearest;
    },
    drawJaggedLine: (ctx,x1,y1,x2,y2,segments) => {
        ctx.beginPath(); ctx.moveTo(x1,y1);
        const dx=x2-x1, dy=y2-y1, dist=Math.sqrt(dx*dx+dy*dy);
        for(let i=1; i<segments; i++){
            const t=i/segments, tx=x1+dx*t, ty=y1+dy*t, offset=(Math.random()-0.5)*(dist/segments)*2;
            ctx.lineTo(tx-dy/dist*offset,ty+dx/dist*offset);
        }
        ctx.lineTo(x2,y2); ctx.stroke();
    },
    drawPolygon: (ctx, x, y, radius, sides, angle = 0, color = 'red') => {
        ctx.fillStyle = color; ctx.beginPath();
        ctx.moveTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
        for (let i = 1; i <= sides; i++) {
            ctx.lineTo(x + radius * Math.cos(angle + i * 2 * Math.PI / sides), y + radius * Math.sin(angle + i * 2 * Math.PI / sides));
        }
        ctx.closePath(); ctx.fill();
    }
};

class Entity {
    constructor(x, y) { this.x = x; this.y = y; this.toRemove = false; }
    update(game) {}
    draw(ctx, game) {}
}
class Player extends Entity {
    constructor() {
        super(CONFIG.world.width / 2, CONFIG.world.height / 2);
        this.baseStats = { ...CONFIG.player.base }; this.keys = {}; this.initStats();
    }
    initStats() {
        this.level = 1; this.xp = 0;
        this.xpNext = CONFIG.player.xpCurve.base;
        this.powerUpTimers = { invincibility: 0, damageBoost: 0 };
        this.stats = { ...this.baseStats };
        this.modifiers = { power: 1, frequency: 1, area: 1, xpGain: 1, luck: 0 };
        this.hp = this.stats.maxHp;
    }
    resetForNewRun(permUpgrades) {
        this.x = CONFIG.world.width / 2; this.y = CONFIG.world.height / 2;
        this.initStats(); this.applyPermanentUpgrades(permUpgrades);
        this.hp = this.stats.maxHp;
    }
    applyPermanentUpgrades(p) {
        this.stats.maxHp = this.baseStats.hp + (p.health.level * 10);
        this.stats.speed = this.baseStats.speed + (p.speed.level * 0.1);
        this.modifiers.xpGain = 1 + (p.xpGain.level * 0.05);
        this.modifiers.luck = p.luck.level * 0.02;
        this.modifiers.power = 1 + (p.power.level * 0.05);
        this.modifiers.frequency = 1 - (p.frequency.level * 0.03);
        this.modifiers.area = 1 + (p.area.level * 0.04);
    }
    update(game, joystick) {
        let kDx = 0, kDy = 0;
        if (this.keys['KeyW'] || this.keys['ArrowUp']) kDy -= 1;
        if (this.keys['KeyS'] || this.keys['ArrowDown']) kDy += 1;
        if (this.keys['KeyA'] || this.keys['ArrowLeft']) kDx -= 1;
        if (this.keys['KeyD'] || this.keys['ArrowRight']) kDx += 1;
        let fDx = joystick.dx !== 0 ? joystick.dx : kDx;
        let fDy = joystick.dy !== 0 ? joystick.dy : kDy;
        const m = Math.sqrt(fDx * fDx + fDy * fDy);
        if (m > 1) { fDx /= m; fDy /= m; }
        this.x += fDx * this.stats.speed; this.y += fDy * this.stats.speed;
        this.x = Math.max(this.stats.radius, Math.min(CONFIG.world.width - this.stats.radius, this.x));
        this.y = Math.max(this.stats.radius, Math.min(CONFIG.world.height - this.stats.radius, this.y));
        for (const key in this.powerUpTimers) { if (this.powerUpTimers[key] > 0) this.powerUpTimers[key]--; }
    }
    gainXP(amount) {
        this.xp += amount * this.modifiers.xpGain;
        return this.xp >= this.xpNext;
    }
    levelUp() {
        this.level++; this.xp -= this.xpNext;
        const c = CONFIG.player.xpCurve;
        this.xpNext = Math.floor(c.base * Math.pow(c.growth, this.level -1) + c.levelFactor * this.level);
        this.hp = this.stats.maxHp; this.powerUpTimers.invincibility = 120;
    }
    takeDamage(amount, game) {
        const shieldSpell = game.spells.shield;
        if ((shieldSpell && shieldSpell.active) || this.powerUpTimers.invincibility > 0) return;
        this.hp -= amount; if (this.hp <= 0) game.gameOver();
    }
    draw(ctx, game) {
        const pulse = Math.sin(Date.now() / 200) * 2;
        ctx.strokeStyle = '#4488ff'; ctx.fillStyle = `rgba(68, 136, 255, 0.2)`; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.stats.radius + pulse, 0, Math.PI * 2); ctx.stroke(); ctx.fill();
        ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, this.stats.radius - 4, 0, Math.PI * 2); ctx.stroke();
        ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI * 2); ctx.fill();
        const shieldSpell = game.spells.shield;
        if ((shieldSpell && shieldSpell.active) || this.powerUpTimers.invincibility > 0) {
            const shieldRadius = this.stats.radius + 8 + Math.sin(Date.now() / 200) * 3;
            const alpha = this.powerUpTimers.invincibility > 0 ? (this.powerUpTimers.invincibility % 60 < 30 ? 0.9 : 0.5) : 0.8;
            ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`; ctx.fillStyle = `rgba(255, 255, 0, ${alpha/4})`; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(this.x, this.y, shieldRadius, 0, Math.PI * 2); ctx.stroke(); ctx.fill();
        }
    }
}
class Enemy extends Entity {
    constructor(x, y, stats) {
        super(x, y); this.stats = stats; this.hp = this.stats.hp;
        this.slowTimer = 0; this.stunTimer = 0; this.color = `hsl(${Math.random() * 60}, 70%, 50%)`;
    }
    update(game) {
        if (this.stunTimer > 0) { this.stunTimer--; return; }
        if (this.slowTimer > 0) this.slowTimer--;
        const player = game.player;
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        const currentSpeed = this.stats.speed * (this.slowTimer > 0 ? (1 - this.stats.slowAmount) : 1);
        this.x += Math.cos(angle) * currentSpeed; this.y += Math.sin(angle) * currentSpeed;
        if (Utils.getDistance(this, player) < this.stats.radius + player.stats.radius) {
            player.takeDamage(this.stats.damage, game);
            const kAngle = Math.atan2(this.y - player.y, this.x - player.x);
            this.x += Math.cos(kAngle) * 20; this.y += Math.sin(kAngle) * 20;
        }
    }
    takeDamage(amount, game) {
        this.hp -= amount;
        if (this.hp <= 0) { this.onDeath(game); this.toRemove = true; }
    }
    onDeath(game) {
        game.enemiesKilled++; game.enemiesKilledSinceBoss++; game.score += Math.floor(this.stats.maxHp);
        game.addEntity('xpOrbs', new XpOrb(this.x, this.y, (2 + Math.floor(Math.random() * 3))));
        if (Math.random() < 0.1 + game.player.modifiers.luck) {
            game.addEntity('gemOrbs', new GemOrb(this.x, this.y, 1 + (Math.random() < game.player.modifiers.luck ? 1 : 0)));
        }
        for (let j = 0; j < 8; j++) {
            game.addEntity('particles', new Particle(this.x, this.y, { vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, life: 20, color: this.color }));
        }
    }
    draw(ctx, game) {
        const angle = Math.atan2(game.player.y - this.y, game.player.x - this.x);
        ctx.fillStyle = this.stunTimer > 0 ? '#ffffff' : (this.slowTimer > 0 ? '#66b2ff' : this.color);
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(angle + Math.PI / 2);
        ctx.beginPath(); ctx.moveTo(0, -this.stats.radius);
        ctx.lineTo(-this.stats.radius * 0.8, this.stats.radius * 0.8);
        ctx.lineTo(this.stats.radius * 0.8, this.stats.radius * 0.8);
        ctx.closePath(); ctx.fill(); ctx.restore();
        if (this.hp < this.stats.maxHp) {
            const barW = this.stats.radius * 2, barH = 4, x = this.x - barW / 2, y = this.y - this.stats.radius - 8;
            ctx.fillStyle = 'rgba(255,0,0,0.7)'; ctx.fillRect(x, y, barW, barH);
            ctx.fillStyle = 'rgba(0,255,0,0.7)'; ctx.fillRect(x, y, barW * (this.hp / this.stats.maxHp), barH);
        }
    }
}
class Boss extends Enemy {
    constructor(x, y, stats) { super(x, y, stats); this.color = '#8e44ad'; this.lastAttack = 0; }
    update(game) {
        super.update(game);
        const now = Date.now();
        if (now - this.lastAttack > CONFIG.boss.attack.cooldown) {
            const angleToPlayer = Math.atan2(game.player.y - this.y, game.player.x - this.x);
            game.addEntity('enemyProjectiles', new Projectile(this.x, this.y, {
                angle: angleToPlayer, speed: CONFIG.boss.attack.projectileSpeed,
                damage: this.stats.damage, radius: CONFIG.boss.attack.projectileRadius,
                life: 300, color: '#ff5555'
            }));
            this.lastAttack = now;
        }
    }
    onDeath(game) {
        super.onDeath(game); game.addEntity('droppedItems', new DroppedItem(this.x, this.y, 'LEGENDARY_ORB'));
        game.gemsThisRun += 50;
    }
    draw(ctx) {
        ctx.fillStyle = this.color; ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 4;
        Utils.drawPolygon(ctx, this.x, this.y, this.stats.radius, 6, Date.now() / 1000); ctx.stroke();
        Utils.drawPolygon(ctx, this.x, this.y, this.stats.radius * 0.7, 6, -Date.now() / 800, 'rgba(255,255,255,0.5)');
        const barW = this.stats.radius * 2, barH = 8, x = this.x - barW / 2, y = this.y - this.stats.radius - 15;
        ctx.fillStyle = '#ff0000'; ctx.fillRect(x, y, barW, barH);
        ctx.fillStyle = '#00ff00'; ctx.fillRect(x, y, barW * (this.hp / this.stats.maxHp), barH);
    }
}
class Projectile extends Entity {
    constructor(x, y, props) {
        super(x, y);
        if (props.angle !== undefined) {
            this.vx = Math.cos(props.angle) * props.speed; this.vy = Math.sin(props.angle) * props.speed;
        }
        Object.assign(this, props); this.penetrated = 0;
    }
    update(game) {
        this.x += this.vx; this.y += this.vy; this.life--;
        if (this.life <= 0) this.toRemove = true;
        if(this.leavesTrail && this.life % 4 === 0){
             game.addEntity('fireTrails', new FireTrail(this.x, this.y, { radius: this.size * 0.7, damage: this.burnDamage }));
        }
        let removed = false;
        const targets = [...game.entities.enemies, ...game.entities.bosses];
        for (const target of targets) {
            if (Utils.getDistance(this, target) < target.stats.radius + (this.size || this.radius)) {
                target.takeDamage(this.damage, game);
                if (this.slow) { target.slowAmount = this.slow; target.slowTimer = this.slowDuration; }
                this.penetrated++;
                if (this.penetrated >= this.penetration) {
                    if (this.type === 'fireball') game.createExplosion(this.x, this.y, this.explosionRadius, this.damage / 2);
                    if (this.type !== 'great_fireball') this.toRemove = true;
                    removed = true;
                    break;
                }
            }
        }
    }
    draw(ctx) {
        if (this.drawFunc) { this.drawFunc(ctx, this); }
        else {
            ctx.fillStyle = this.color || '#ffaa00'; ctx.beginPath();
            ctx.arc(this.x, this.y, this.size || this.radius, 0, Math.PI * 2); ctx.fill();
        }
    }
}
class XpOrb extends Entity {
    constructor(x,y,value) { super(x,y); this.value = value; }
    update(game) {
        const player = game.player;
        const pickupRadius = CONFIG.xpOrbs.pickupRadius * (1 + (player.modifiers.area - 1) * 0.5);
        const dist = Utils.getDistance(this, player);
        if (dist < pickupRadius) {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            const speed = Math.max(4, (pickupRadius - dist) * 0.1);
            this.x += Math.cos(angle) * speed; this.y += Math.sin(angle) * speed;
        }
        if (dist < 20) {
            if(player.gainXP(this.value)) game.handleLevelUp();
            this.toRemove = true;
        }
    }
    draw(ctx) { ctx.fillStyle = '#00ff88'; ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI * 2); ctx.fill(); }
}
class GemOrb extends Entity {
    constructor(x,y,value) { super(x,y); this.value = value; }
    update(game) {
        const player = game.player;
        const dist = Utils.getDistance(this, player);
        if (dist < 120) {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            this.x += Math.cos(angle) * 5; this.y += Math.sin(angle) * 5;
        }
        if (dist < 20) { game.gemsThisRun += this.value; this.toRemove = true; }
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(Date.now()/500);
        ctx.fillStyle = '#72f5f5'; ctx.strokeStyle = 'white'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(0, -7); ctx.lineTo(7, 0); ctx.lineTo(0, 7); ctx.lineTo(-7, 0);
        ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
    }
}
class Chest extends Entity {
    constructor(x,y) { super(x,y); this.size = CONFIG.chest.size; }
    update(game) {
        const dist = Utils.getDistance(game.player, {x: this.x + this.size/2, y: this.y + this.size/2});
        if (dist < game.player.stats.radius + this.size) {
            const itemKeys = Object.keys(CONFIG.itemTypes).filter(k => k !== 'LEGENDARY_ORB');
            const randomType = itemKeys[Math.floor(Math.random() * itemKeys.length)];
            game.addEntity('droppedItems', new DroppedItem(this.x + this.size / 2, this.y - 10, randomType));
            if (Math.random() < 0.5 + game.player.modifiers.luck) {
                let c = CONFIG.chest.gemDrop;
                let gemsFound = c.min + Math.floor(Math.random() * c.random * (1 + game.player.modifiers.luck));
                game.gemsThisRun += gemsFound;
            }
            this.toRemove = true;
        }
    }
    draw(ctx) {
        ctx.fillStyle = '#8B4513'; ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(this.x + this.size * 0.3, this.y - this.size * 0.2, this.size * 0.4, this.size*0.4);
        ctx.fillRect(this.x + this.size * 0.4, this.y + this.size * 0.4, this.size*0.2, this.size*0.3);
    }
}
class DroppedItem extends Entity {
    constructor(x,y,type) { super(x,y); this.type = type; this.life = 600; }
    update(game) {
        this.life--; if (this.life <= 0) this.toRemove = true;
        const dist = Utils.getDistance(game.player, this);
        if (dist < game.player.stats.radius + 10) { game.applyItemEffect(this); this.toRemove = true; }
    }
    draw(ctx) {
        const itemInfo = CONFIG.itemTypes[this.type]; ctx.save();
        ctx.globalAlpha = this.life > 60 ? 1.0 : Math.max(0, this.life / 60);
        const bob = Math.sin(Date.now()/200 + this.x) * 3;
        ctx.fillStyle = itemInfo.color; ctx.beginPath();
        ctx.arc(this.x, this.y + bob, 10, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore();
    }
}
class Particle extends Entity {
    constructor(x, y, props) { super(x,y); Object.assign(this, props); }
    update() { this.x += this.vx; this.y += this.vy; this.life--; if (this.life <= 0) this.toRemove = true; }
    draw(ctx) {
        ctx.globalAlpha = this.life / 30; ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1;
    }
}
class FireTrail extends Entity {
    constructor(x,y,props) { super(x,y); this.radius = props.radius; this.damage = props.damage; this.life = 60; this.initialLife = 60;}
    update(game) {
        this.life--; if (this.life <= 0) this.toRemove = true;
        [...game.entities.enemies, ...game.entities.bosses].forEach(enemy => {
            if (Utils.getDistance(enemy, this) < enemy.stats.radius + this.radius) { enemy.takeDamage(this.damage / 60, game); }
        });
    }
    draw(ctx) {
        ctx.globalAlpha = (this.life / this.initialLife) * 0.7;
        const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, this.radius);
        g.addColorStop(0, 'rgba(255, 150, 0, 0.8)'); g.addColorStop(1, 'rgba(255, 50, 0, 0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}
class Effect extends Entity {
    constructor(x,y,props) { super(x,y); Object.assign(this, props); }
    update() { this.life--; if (this.life <= 0) this.toRemove = true; }
    draw(ctx) {
        const opacity = this.life / this.initialLife;
        if (this.type === 'emp_wave' || this.type === 'explosion' || this.type === 'level_up_burst') {
            const currentRadius = this.maxRadius * (1 - opacity); let color = '136,170,255';
            if (this.type === 'explosion') color = '255,150,0'; if (this.type === 'level_up_burst') color = '255,215,0';
            ctx.strokeStyle=`rgba(${color},${opacity})`; ctx.lineWidth=5;
            ctx.beginPath(); ctx.arc(this.x,this.y,currentRadius,0,Math.PI*2); ctx.stroke();
        } else if (this.type === 'lightning_chain') {
            ctx.strokeStyle = `rgba(255,255,0,${opacity})`; ctx.lineWidth = Math.random() * 3 + 2;
            Utils.drawJaggedLine(ctx, this.from.x, this.from.y, this.to.x, this.to.y, 10);
        } else if (this.type === 'meteor_indicator') {
            ctx.strokeStyle=`rgba(255,100,0,${1 - opacity})`; ctx.lineWidth=3;
            ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.stroke();
        }
    }
}

class BallSurvivalGame {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId); this.ctx = this.canvas.getContext('2d');
        this.initDOM(); this.initInputHandlers();
        this.camera = { x: 0, y: 0, width: this.canvas.width, height: this.canvas.height };
        this.player = new Player();
        this.joystick = { dx: 0, dy: 0, ...this.dom.joystick };
        this.state = 'startScreen'; this.lastFrameTime = 0; this.totalElapsedTime = 0; this.menuCooldown = 0;
        this.loadGameData(); this.resetRunState(); this.resizeCanvas();
        this.showPopup('start');
    }
    initDOM() {
        this.dom = {
            gameContainer: document.getElementById('gameContainer'),
            ui: { hp: document.getElementById('hp'), level: document.getElementById('level'), xp: document.getElementById('xp'), xpNext: document.getElementById('xpNext'), enemies: document.getElementById('enemies'), time: document.getElementById('time'), score: document.getElementById('score'), totalGemsUI: document.getElementById('totalGemsUI'), runGemsUI: document.getElementById('runGemsUI')},
            popups: { start: document.getElementById('startScreen'), pause: document.getElementById('pauseMenu'), gameOver: document.getElementById('gameOver'), upgrade: document.getElementById('upgradeMenu'), shop: document.getElementById('permanentUpgradeShop') },
            buttons: { start: document.getElementById('startGameBtn'), restart: document.getElementById('restartGameBtn'), restartFromPause: document.getElementById('restartFromPauseBtn'), pause: document.getElementById('pauseButton') },
            joystick: { container: document.getElementById('joystick-container'), stick: document.getElementById('joystick-stick'), active: false, radius: 60, touchId: null },
            menuOverlay: document.getElementById('menuOverlay'),
            totalGemsShop: document.getElementById('totalGemsShop'),
            permanentUpgradeOptions: document.getElementById('permanentUpgradeOptions'),
            upgradeOptions: document.getElementById('upgradeOptions'),
            playerStatsColumn: document.getElementById('playerStatsColumn'),
            weaponsStatsColumn: document.getElementById('weaponsStatsColumn')
        };
    }
    initInputHandlers() {
        window.addEventListener('resize', () => this.resizeCanvas());
        this.dom.buttons.start.onclick = () => this.startGame();
        this.dom.buttons.restart.onclick = () => this.startGame();
        this.dom.buttons.restartFromPause.onclick = () => this.startGame();
        this.dom.buttons.pause.onclick = () => this.togglePause();
        this.dom.menuOverlay.onclick = () => this.hideAllPopups();
        Object.values(this.dom.popups).forEach(p => p.addEventListener('click', e => e.stopPropagation()));
        document.addEventListener('keydown', (e) => {
            this.player.keys[e.code] = true;
            if (e.code === 'Escape') this.handleEscapeKey();
            if (e.code === 'KeyE') this.handleInteractionKey();
        });
        document.addEventListener('keyup', (e) => { this.player.keys[e.code] = false; });
        this.canvas.addEventListener('pointerdown', this.handlePointerDown.bind(this));
        this.canvas.addEventListener('pointermove', this.handlePointerMove.bind(this));
        this.canvas.addEventListener('pointerup', this.handlePointerEnd.bind(this));
        this.canvas.addEventListener('pointercancel', this.handlePointerEnd.bind(this));
    }
    startGame() {
        this.hideAllPopups(true); this.dom.buttons.pause.style.display = 'flex';
        this.resetRunState(); this.player.resetForNewRun(this.permanentUpgrades);
        this.state = 'running'; this.lastFrameTime = performance.now();
        if (!this.gameLoopId) this.gameLoop();
    }
    gameOver() {
        this.state = 'gameOver'; this.totalGems += this.gemsThisRun; this.saveGameData();
        document.getElementById('survivalTime').textContent = Math.floor(this.totalElapsedTime);
        document.getElementById('enemiesKilled').textContent = this.enemiesKilled;
        document.getElementById('gemsEarned').textContent = this.gemsThisRun;
        document.getElementById('finalScore').textContent = this.score;
        this.dom.buttons.pause.style.display = 'none';
        this.hideAllPopups(); this.showPopup('gameOver');
    }
    resetRunState() {
        this.entities = { enemies: [], bosses: [], projectiles: [], enemyProjectiles: [], xpOrbs: [], gemOrbs: [], particles: [], effects: [], chests: [], droppedItems: [], fireTrails: [] };
        this.notifications = []; this.score = 0; this.enemiesKilled = 0; this.gemsThisRun = 0;
        this.totalElapsedTime = 0; this.enemiesKilledSinceBoss = 0;
        this.nextChestSpawnTime = CONFIG.chest.spawnTime; this.nextMapXpSpawnTime = 5;
        
        // FIX: Inizializza il timer di spawn dei nemici
        this.lastEnemySpawnTime = 0; 

        this.resetSpells();
    }
    gameLoop() {
        this.gameLoopId = requestAnimationFrame(this.gameLoop.bind(this));
        const now = performance.now(); const deltaTime = (now - this.lastFrameTime) / 1000;
        if (this.state === 'running') {
            this.totalElapsedTime += deltaTime;
            if (this.menuCooldown > 0) this.menuCooldown--;
            this.update(deltaTime);
        }
        this.draw(); this.updateUI(); this.lastFrameTime = now;
    }
    update() {
        this.player.update(this, this.joystick); this.updateCamera();
        for (const type in this.entities) {
            for (let i = this.entities[type].length - 1; i >= 0; i--) {
                const entity = this.entities[type][i];
                entity.update(this);
                if (entity.toRemove) this.entities[type].splice(i, 1);
            }
        }
        for (let i = this.notifications.length - 1; i >= 0; i--) {
            this.notifications[i].life--;
            if (this.notifications[i].life <= 0) this.notifications.splice(i, 1);
        }
        this.spawnEnemies(); this.spawnBoss(); this.spawnChests(); this.spawnMapXpOrbs();
        this.castSpells();
    }
    draw() {
        this.ctx.fillStyle = 'black'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.save(); this.ctx.translate(-this.camera.x, -this.camera.y);
        this.drawBackground();
        Object.values(this.entities).flat().forEach(e => e.draw(this.ctx, this));
        this.drawMerchant(); this.player.draw(this.ctx, this);
        this.ctx.restore();
        this.drawOffscreenIndicators(); this.drawNotifications();
    }
    drawBackground() {
        this.ctx.fillStyle = '#16213e'; this.ctx.fillRect(0, 0, CONFIG.world.width, CONFIG.world.height);
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)'; this.ctx.lineWidth = 2;
        for (let x = 0; x < CONFIG.world.width; x += CONFIG.world.gridSize) {
            this.ctx.beginPath(); this.ctx.moveTo(x, 0); this.ctx.lineTo(x, CONFIG.world.height); this.ctx.stroke();
        }
        for (let y = 0; y < CONFIG.world.height; y += CONFIG.world.gridSize) {
            this.ctx.beginPath(); this.ctx.moveTo(0, y); this.ctx.lineTo(CONFIG.world.width, y); this.ctx.stroke();
        }
    }
    addEntity(type, entity) { if (this.entities[type]) this.entities[type].push(entity); }
    spawnEnemies() {
        if (this.lastEnemySpawnTime && (this.totalElapsedTime - this.lastEnemySpawnTime < CONFIG.enemies.spawnInterval)) return;
        this.lastEnemySpawnTime = this.totalElapsedTime;
        const maxEnemies = 50 + Math.floor(this.totalElapsedTime / 15);
        if (this.entities.enemies.length >= maxEnemies) return;
        const side = Math.floor(Math.random() * 4);
        let x, y; const buffer = 50;
        switch (side) {
            case 0: x = this.camera.x + Math.random() * this.camera.width; y = this.camera.y - buffer; break;
            case 1: x = this.camera.x + this.camera.width + buffer; y = this.camera.y + Math.random() * this.camera.height; break;
            case 2: x = this.camera.x + Math.random() * this.camera.width; y = this.camera.y + this.camera.height + buffer; break;
            case 3: x = this.camera.x - buffer; y = this.camera.y + Math.random() * this.camera.height; break;
        }
        const timeFactor = this.totalElapsedTime / CONFIG.enemies.scaling.timeFactor;
        const stats = { ...CONFIG.enemies.base, hp: CONFIG.enemies.base.hp + Math.floor(timeFactor) * CONFIG.enemies.scaling.hpPerFactor, speed: (CONFIG.enemies.base.speed + Math.random() * 0.4) + timeFactor * CONFIG.enemies.scaling.speedPerFactor, damage: CONFIG.enemies.base.damage + Math.floor(timeFactor) * CONFIG.enemies.scaling.damagePerFactor, };
        stats.maxHp = stats.hp; this.addEntity('enemies', new Enemy(x, y, stats));
    }
    spawnBoss() {
        if (this.entities.bosses.length === 0 && this.enemiesKilledSinceBoss >= CONFIG.boss.spawnThreshold) {
            const side = Math.floor(Math.random() * 4); let x, y; const buffer = 100;
            switch (side) {
                case 0: x = this.camera.x + Math.random() * this.camera.width; y = this.camera.y - buffer; break;
                case 1: x = this.camera.x + this.camera.width + buffer; y = this.camera.y + Math.random() * this.camera.height; break;
                case 2: x = this.camera.x + Math.random() * this.camera.width; y = this.camera.y + this.camera.height + buffer; break;
                case 3: x = this.camera.x - buffer; y = this.camera.y + Math.random() * this.camera.height; break;
            }
            const timeFactor = this.totalElapsedTime / CONFIG.boss.scaling.timeFactor;
            const stats = { ...CONFIG.boss.base, hp: CONFIG.boss.base.hp + timeFactor * CONFIG.boss.scaling.hpPerFactor, };
            stats.maxHp = stats.hp; this.addEntity('bosses', new Boss(x, y, stats));
            this.notifications.push({ text: "!!! UN BOSS Ãˆ APPARSO !!!", life: 300 }); this.enemiesKilledSinceBoss = 0;
        }
    }
    spawnChests() {
        if (this.entities.chests.length === 0 && this.totalElapsedTime > this.nextChestSpawnTime) {
            const buffer = 200; let x, y, dist;
            do { x = Math.random() * (CONFIG.world.width - buffer * 2) + buffer; y = Math.random() * (CONFIG.world.height - buffer * 2) + buffer; dist = Utils.getDistance({ x, y }, this.player); }
            while (dist < this.camera.width);
            this.addEntity('chests', new Chest(x,y));
            this.nextChestSpawnTime = this.totalElapsedTime + CONFIG.chest.respawnTime;
        }
    }
    spawnMapXpOrbs() {
        const c = CONFIG.xpOrbs.mapSpawn;
        if (this.totalElapsedTime > this.nextMapXpSpawnTime) {
            if (this.entities.xpOrbs.length < c.max - c.batch) {
                const clusterCenterX = Math.random() * CONFIG.world.width; const clusterCenterY = Math.random() * CONFIG.world.height;
                for (let i = 0; i < c.batch; i++) {
                    const x = clusterCenterX + (Math.random() - 0.5) * 400; const y = clusterCenterY + (Math.random() - 0.5) * 400;
                    const finalX = Math.max(0, Math.min(CONFIG.world.width - 1, x)); const finalY = Math.max(0, Math.min(CONFIG.world.height - 1, y));
                    this.addEntity('xpOrbs', new XpOrb(finalX, finalY, c.value));
                }
            }
            this.nextMapXpSpawnTime = this.totalElapsedTime + c.interval;
        }
    }
    resetSpells() { this.spells = { magicMissile: { id: 'magicMissile', name: "Proiettile Magico", level: 1, damage: 14, cooldown: 1200, lastCast: 0, speed: 6, size: 5, area: 5 }, fireball:     { id: 'fireball', name: "Sfera di Fuoco", level: 0, evolution: 'none', damage: 15, cooldown: 1200, lastCast: 0, size: 8, speed: 7, explosionRadius: 20, penetration: 1, burnDamage: 5, burnDuration: 180, meteorCount: 3, area: 20 }, lightning:    { id: 'lightning', name: "Fulmine a Catena", level: 0, damage: 10, cooldown: 1200, lastCast: 0, range: 250, chains: 2 }, frostbolt:    { id: 'frostbolt', name: "Dardo di Gelo", level: 0, damage: 12, cooldown: 1200, lastCast: 0, slow: 0.5, slowDuration: 120, size: 7, speed: 6, penetration: 1, area: 7 }, shotgun:      { id: 'shotgun', name: "Fucile Arcano", level: 0, damage: 8, count: 5, angleSpread: Math.PI / 4, cooldown: 1500, lastCast: 0 }, shockwave:    { id: 'shockwave', name: "Onda d'Urto", level: 0, damage: 20, radius: 100, cooldown: 8000, lastCast: 0, knockback: 15, area: 100 }, heal:         { id: 'heal', name: "Cura", level: 0, amount: 20, cooldown: 10000, lastCast: 0 }, shield:       { id: 'shield', name: "Scudo Magico", level: 0, duration: 3000, cooldown: 12000, lastCast: 0, active: false } }; this.passives = { health: { level: 0 }, speed: { level: 0 }, attack_speed: { level: 0 } }; }
    castSpells() { const now = Date.now(); const freq = this.player.modifiers.frequency; if (this.spells.magicMissile.level > 0 && now - this.spells.magicMissile.lastCast > this.spells.magicMissile.cooldown * freq) this.castMagicMissile(now); if (this.spells.fireball.level > 0 && now - this.spells.fireball.lastCast > this.spells.fireball.cooldown * freq) this.castFireball(now); if (this.spells.shotgun.level > 0 && now - this.spells.shotgun.lastCast > this.spells.shotgun.cooldown * freq) this.castShotgun(now); if (this.spells.shockwave.level > 0 && now - this.spells.shockwave.lastCast > this.spells.shockwave.cooldown * freq) this.castShockwave(now); if (this.spells.lightning.level > 0 && now - this.spells.lightning.lastCast > this.spells.lightning.cooldown * freq) this.castLightning(now); if (this.spells.frostbolt.level > 0 && now - this.spells.frostbolt.lastCast > this.spells.frostbolt.cooldown * freq) this.castFrostbolt(now); if (this.spells.heal.level > 0 && this.player.hp < this.player.stats.maxHp && now - this.spells.heal.lastCast > this.spells.heal.cooldown * freq) this.castHeal(now); if (this.spells.shield.level > 0 && !this.spells.shield.active && now - this.spells.shield.lastCast > this.spells.shield.cooldown * freq) this.castShield(now); }
    getDamage(baseDamage) { return baseDamage * (this.player.powerUpTimers.damageBoost > 0 ? 1.25 : 1) * this.player.modifiers.power; }
    castMagicMissile(now) { const s = this.spells.magicMissile; const nearest = Utils.findNearest(this.player, [...this.entities.enemies, ...this.entities.bosses]); if (!nearest) return; const angle = Math.atan2(nearest.y - this.player.y, nearest.x - this.player.x); this.addEntity('projectiles', new Projectile(this.player.x, this.player.y, { angle, damage: this.getDamage(s.damage), speed: s.speed, life: 80, size: s.size * this.player.modifiers.area, penetration: 1, color: '#9d75ff' })); s.lastCast = now; }
    castFireball(now) { const s = this.spells.fireball; if (s.evolution === 'giant') return this.castGreatFireball(now); if (s.evolution === 'meteor') return this.castMeteorShower(now); const nearest = Utils.findNearest(this.player, [...this.entities.enemies, ...this.entities.bosses]); if (!nearest) return; const angle = Math.atan2(nearest.y - this.player.y, nearest.x - this.player.x); this.addEntity('projectiles', new Projectile(this.player.x, this.player.y, { angle, damage: this.getDamage(s.damage), type: 'fireball', life: 100, speed: s.speed, size: s.size * this.player.modifiers.area, penetration: 1, explosionRadius: s.explosionRadius * this.player.modifiers.area, drawFunc: (ctx, p) => { const g = ctx.createRadialGradient(p.x, p.y, p.size / 2, p.x, p.y, p.size * 1.5); g.addColorStop(0, 'rgba(255,200,0,1)'); g.addColorStop(0.5, 'rgba(255,100,0,0.8)'); g.addColorStop(1, 'rgba(255,0,0,0)'); ctx.fillStyle = g; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * 1.5, 0, Math.PI * 2); ctx.fill(); } })); s.lastCast = now; }
    castGreatFireball(now) { const s = this.spells.fireball; const nearest = Utils.findNearest(this.player, [...this.entities.enemies, ...this.entities.bosses]); if (!nearest) return; const angle = Math.atan2(nearest.y - this.player.y, nearest.x - this.player.x); this.addEntity('projectiles', new Projectile(this.player.x, this.player.y, { angle, damage: this.getDamage(s.damage), type: 'great_fireball', life: 200, speed: s.speed, size: s.size * this.player.modifiers.area, penetration: 999, leavesTrail: true, burnDamage: s.burnDamage * this.player.modifiers.power, drawFunc: (ctx, p) => { const g = ctx.createRadialGradient(p.x, p.y, p.size / 4, p.x, p.y, p.size); g.addColorStop(0, 'rgba(255, 255, 255, 1)'); g.addColorStop(0.2, 'rgba(255, 220, 150, 1)'); g.addColorStop(0.6, 'rgba(255, 100, 0, 0.9)'); g.addColorStop(1, 'rgba(150, 0, 0, 0)'); ctx.fillStyle = g; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); } })); s.lastCast = now; }
    castMeteorShower(now) { const s = this.spells.fireball; const visibleEnemies = [...this.entities.enemies, ...this.entities.bosses].filter(e => e.x > this.camera.x && e.x < this.camera.x + this.camera.width && e.y > this.camera.y && e.y < this.camera.y + this.camera.height); for (let i = 0; i < s.meteorCount; i++) { let target = visibleEnemies.length > 0 ? visibleEnemies[Math.floor(Math.random() * visibleEnemies.length)] : { x: this.player.x + (Math.random() - 0.5) * 400, y: this.player.y + (Math.random() - 0.5) * 400 }; let explosionRadius = s.explosionRadius * this.player.modifiers.area; this.addEntity('effects', new Effect(target.x, target.y, { type: 'meteor_indicator', radius: explosionRadius, life: 45, initialLife: 45 })); setTimeout(() => { this.createExplosion(target.x, target.y, explosionRadius, this.getDamage(s.damage)); for(let k=0; k<10; k++) this.addEntity('particles', new Particle(target.x, target.y, { vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 30, color: '#ffaa00' })); }, 750); } s.lastCast = now; }
    castShotgun(now) { const s = this.spells.shotgun; const nearest = Utils.findNearest(this.player, [...this.entities.enemies, ...this.entities.bosses]); if (!nearest) return; const angleBase = Math.atan2(nearest.y - this.player.y, nearest.x - this.player.x); for (let i = 0; i < s.count; i++) { const offset = (i - (s.count-1) / 2) * (s.angleSpread / s.count); this.addEntity('projectiles', new Projectile(this.player.x, this.player.y, { angle: angleBase + offset, damage: this.getDamage(s.damage), speed: 10, life: 30, size: 4 * this.player.modifiers.area, penetration: 1, color: '#ffaa00' })); } s.lastCast = now; }
    castShockwave(now) { const s = this.spells.shockwave; const radius = s.radius * this.player.modifiers.area; for (let enemy of [...this.entities.enemies, ...this.entities.bosses]) { if (Utils.getDistance(this.player, enemy) <= radius) { enemy.takeDamage(this.getDamage(s.damage), this); const kAngle = Math.atan2(enemy.y - this.player.y, enemy.x - this.player.x); enemy.x += Math.cos(kAngle) * s.knockback; enemy.y += Math.sin(kAngle) * s.knockback; } } this.addEntity('effects', new Effect(this.player.x, this.player.y, { type: 'emp_wave', maxRadius: radius, life: 30, initialLife: 30 })); s.lastCast = now; }
    castLightning(now) { const s = this.spells.lightning; const nearest = Utils.findNearest(this.player, [...this.entities.enemies, ...this.entities.bosses], s.range); if (!nearest) return; s.lastCast = now; let lastTarget = this.player; let chainedEnemies = []; for (let c = 0; c < s.chains; c++) { let nextTarget = Utils.findNearest(lastTarget, [...this.entities.enemies, ...this.entities.bosses].filter(e => !chainedEnemies.includes(e)), 200); if (nextTarget) { nextTarget.takeDamage(this.getDamage(s.damage), this); this.addEntity('effects', new Effect(0, 0, { type: 'lightning_chain', from: { x: lastTarget.x, y: lastTarget.y }, to: { x: nextTarget.x, y: nextTarget.y }, life: 10, initialLife: 10 })); lastTarget = nextTarget; chainedEnemies.push(nextTarget); } else break; } }
    castFrostbolt(now) { const s = this.spells.frostbolt; const nearest = Utils.findNearest(this.player, [...this.entities.enemies, ...this.entities.bosses]); if (!nearest) return; const angle = Math.atan2(nearest.y - this.player.y, nearest.x - this.player.x); this.addEntity('projectiles', new Projectile(this.player.x, this.player.y, { angle, damage: this.getDamage(s.damage), speed: s.speed, life: 100, size: s.size * this.player.modifiers.area, penetration: s.penetration, slow: s.slow, slowDuration: s.slowDuration, drawFunc: (ctx, p) => { ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(Date.now() / 100); ctx.fillStyle = '#add8e6'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; const spikes = 6, outerR = p.size, innerR = p.size / 2; ctx.beginPath(); for (let i = 0; i < spikes * 2; i++) { const r = i % 2 === 0 ? outerR : innerR; const a = (i * Math.PI) / spikes; ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r); } ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore(); } })); s.lastCast = now; }
    castHeal(now) { const s = this.spells.heal; this.player.hp = Math.min(this.player.stats.maxHp, this.player.hp + s.amount); for(let i=0; i<10; i++) this.addEntity('particles', new Particle(this.player.x, this.player.y, {vx:(Math.random()-0.5)*2, vy:(Math.random()-0.5)*4 - 2, life: 40, color: '#00ff00'})); s.lastCast = now; }
    castShield(now) { const s = this.spells.shield; s.active = true; s.lastCast = now; setTimeout(() => { s.active = false; }, s.duration); }
    createExplosion(x, y, radius, damage) { this.addEntity('effects', new Effect(x, y, { type: 'explosion', maxRadius: radius, life: 20, initialLife: 20 })); for (let enemy of [...this.entities.enemies, ...this.entities.bosses]) { if (Utils.getDistance({x,y}, enemy) <= radius) enemy.takeDamage(this.getDamage(damage), this); } }
    handleLevelUp() { this.player.levelUp(); this.addEntity('effects', new Effect(this.player.x, this.player.y, { type: 'level_up_burst', maxRadius: 60, life: 30, initialLife: 30 })); this.notifications.push({ text: "Scudo temporaneo attivato!", life: 120 }); this.populateUpgradeMenu(); this.showPopup('upgrade'); }
    populateUpgradeMenu() { const container = this.dom.upgradeOptions; container.innerHTML = ''; const choices = this.getUpgradeChoices(); choices.forEach(upgrade => { if (!upgrade) return; const div = document.createElement('div'); div.className = 'upgrade-option' + (upgrade.type === 'evolution' ? ' evolution' : ''); let baseId = upgrade.id.split('_')[0]; let s = upgrade.type === 'passive' ? this.passives[upgrade.id] : this.spells[baseId]; let levelText = s && s.level > 0 ? `(Liv. ${s.level + 1})` : `(Nuovo!)`; if (upgrade.type === 'evolution' || upgrade.id.includes('mastery')) levelText = ''; div.innerHTML = `<div class="upgrade-title">${upgrade.name} ${levelText}</div><div class="upgrade-desc">${upgrade.details || upgrade.desc}</div>`; div.onclick = () => { this.applyUpgrade(upgrade.id); this.hideAllPopups(); }; container.appendChild(div); }); }
    getUpgradeChoices() { let choices = []; const fireball = this.spells.fireball; const upgradeTree = CONFIG.upgradeTree; if (fireball.level === upgradeTree.fireball.maxLevel && fireball.evolution === 'none') { choices.push(upgradeTree.fireball_evolve_giant, upgradeTree.fireball_evolve_meteor); } let newSkillsPool = [], otherUpgradesPool = []; Object.keys(upgradeTree).forEach(id => { const upgrade = upgradeTree[id]; if (id === 'magicMissile' || upgrade.type === 'evolution') return; const baseId = upgrade.id.split('_')[0]; const spell = this.spells[baseId]; if (upgrade.type === 'passive') { if (!this.passives[id] || this.passives[id].level < upgrade.maxLevel) { otherUpgradesPool.push(upgrade); } } else if (spell && spell.level === 0 && !id.includes('mastery')) { newSkillsPool.push(upgrade); } else if (spell && spell.level > 0) { if (upgrade.id === baseId && spell.level < upgradeTree[baseId].maxLevel && spell.evolution === 'none') { otherUpgradesPool.push(upgrade); } else if (spell.evolution === 'giant' && upgrade.id === 'fireball_giant_mastery') { otherUpgradesPool.push(upgrade); } else if (spell.evolution === 'meteor' && upgrade.id === 'fireball_meteor_mastery') { otherUpgradesPool.push(upgrade); } } }); newSkillsPool = [...new Set(newSkillsPool)]; otherUpgradesPool = [...new Set(otherUpgradesPool)]; if (choices.length < 3 && newSkillsPool.length > 0) { choices.push(newSkillsPool.splice(Math.floor(Math.random() * newSkillsPool.length), 1)[0]); } const combinedPool = [...newSkillsPool, ...otherUpgradesPool]; while (choices.length < 3 && combinedPool.length > 0) { choices.push(combinedPool.splice(Math.floor(Math.random() * combinedPool.length), 1)[0]); } return choices; }
    applyUpgrade(upgradeId) { const upgrade = CONFIG.upgradeTree[upgradeId]; if (!upgrade) return; let target; let baseId = upgrade.id.split('_')[0]; if (upgrade.type === 'passive') { if (!this.passives[upgrade.id]) this.passives[upgrade.id] = { level: 0 }; target = this.passives[upgrade.id]; } else { if (!this.spells[baseId]) this.spells[baseId] = { level: 0, id: baseId, evolution: 'none', damage: 0, cooldown: 0, area: 0 }; target = this.spells[baseId]; } target.level++; if (upgradeId.includes('evolve')) target.evolution = upgradeId.includes('giant') ? 'giant' : 'meteor'; else if (upgrade.id === 'fireball') { target.damage += 5; target.explosionRadius += 5; target.area = target.explosionRadius; } else if (upgrade.id === 'fireball_evolve_giant') { target.damage = 60; target.size = 35; target.speed = 2; target.cooldown = 2500; target.area = target.size; } else if (upgrade.id === 'fireball_evolve_meteor') { target.cooldown = 2000; target.damage = 25; } else if (upgrade.id === 'fireball_giant_mastery') { target.damage += 30; target.burnDamage += 5; } else if (upgrade.id === 'fireball_meteor_mastery') { target.meteorCount++; target.explosionRadius += 10; target.area = target.explosionRadius; } else if (upgrade.id === 'lightning') { target.damage += 4; target.chains++; } else if (upgrade.id === 'frostbolt') { target.damage += 3; target.penetration++; } else if (upgrade.id === 'shotgun') { target.damage += 2; target.count += 2; } else if (upgrade.id === 'shockwave') { target.damage += 10; target.radius += 15; target.knockback += 5; target.area = target.radius; } else if (upgrade.id === 'heal') { target.amount += 10; target.cooldown = Math.max(4000, target.cooldown - 1000); } else if (upgrade.id === 'shield') { target.duration += 1000; target.cooldown = Math.max(5000, target.cooldown - 1500); } else if (upgrade.id === 'health') { this.player.stats.maxHp += 25; this.player.hp += 25; } else if (upgrade.id === 'speed') { this.player.stats.speed += 0.4; } else if (upgrade.id === 'attack_speed') { this.player.modifiers.frequency *= 0.92; } }
    updateUI() { const ui = this.dom.ui; ui.hp.textContent = `${Math.max(0, Math.floor(this.player.hp))}/${this.player.stats.maxHp}`; ui.level.textContent = this.player.level; ui.xp.textContent = Math.floor(this.player.xp); ui.xpNext.textContent = this.player.xpNext; ui.enemies.textContent = this.entities.enemies.length + this.entities.bosses.length; ui.time.textContent = Math.floor(this.totalElapsedTime); ui.score.textContent = this.score; ui.totalGemsUI.textContent = this.totalGems; ui.runGemsUI.textContent = this.gemsThisRun; }
    showPopup(popupKey) { this.state = (popupKey === 'gameOver' || popupKey === 'start') ? popupKey : 'paused'; this.dom.menuOverlay.style.display = 'block'; Object.values(this.dom.popups).forEach(p => p.style.display = 'none'); this.dom.popups[popupKey].style.display = 'flex'; if (popupKey === 'shop') this.populateShop(); if (popupKey === 'pause') this.populateStatsMenu(); }
    hideAllPopups(forceNoResume) { Object.values(this.dom.popups).forEach(p => p.style.display = 'none'); this.dom.menuOverlay.style.display = 'none'; if (this.state === 'paused' && !forceNoResume) { this.state = 'running'; this.lastFrameTime = performance.now(); this.menuCooldown = 5; } }
    togglePause() { if (this.state !== 'running' && this.state !== 'paused') return; if (this.state === 'running') { this.showPopup('pause'); } else { this.hideAllPopups(); } }
    populateStatsMenu() { const p = this.player; let playerHTML = `<div class="stats-section"><div class="stats-section-title">Statistiche Giocatore</div>`; playerHTML += `<div class="stat-item">${CONFIG.statIcons.health}<span class="stat-item-label">Salute:</span><span class="stat-item-value">${Math.floor(p.hp)} / ${p.stats.maxHp}</span></div>`; playerHTML += `<div class="stat-item">${CONFIG.statIcons.speed}<span class="stat-item-label">VelocitÃ :</span><span class="stat-item-value">${p.stats.speed.toFixed(1)}</span></div></div>`; playerHTML += `<div class="stats-section"><div class="stats-section-title">Modificatori</div>`; playerHTML += `<div class="stat-item">${CONFIG.statIcons.power}<span class="stat-item-label">Potenza:</span><span class="stat-item-value">+${Math.round((p.modifiers.power - 1) * 100)}%</span></div>`; playerHTML += `<div class="stat-item">${CONFIG.statIcons.frequency}<span class="stat-item-label">Frequenza:</span><span class="stat-item-value">+${Math.round((1 - p.modifiers.frequency) * 100)}%</span></div>`; playerHTML += `<div class="stat-item">${CONFIG.statIcons.area}<span class="stat-item-label">Area:</span><span class="stat-item-value">+${Math.round((p.modifiers.area - 1) * 100)}%</span></div>`; playerHTML += `<div class="stat-item">${CONFIG.statIcons.xpGain}<span class="stat-item-label">Guadagno XP:</span><span class="stat-item-value">+${Math.round((p.modifiers.xpGain - 1) * 100)}%</span></div>`; playerHTML += `<div class="stat-item">${CONFIG.statIcons.luck}<span class="stat-item-label">Fortuna:</span><span class="stat-item-value">+${Math.round(p.modifiers.luck * 100)}%</span></div></div>`; this.dom.playerStatsColumn.innerHTML = playerHTML; let weaponsHTML = `<div class="stats-section"><div class="stats-section-title">Armi e AbilitÃ </div>`; let hasWeapons = false; Object.values(this.spells).filter(s => s.level > 0).forEach(s => { hasWeapons = true; weaponsHTML += `<div class="stat-item-title">${s.name} (Liv. ${s.level})</div>`; let details = ''; if (s.damage) details += `Danno: ${Math.round(this.getDamage(s.damage))}, `; if (s.cooldown) details += `Ricarica: ${(s.cooldown * p.modifiers.frequency / 1000).toFixed(2)}s, `; if (s.area) details += `Area: ${Math.round(s.area * p.modifiers.area)}, `; if (s.count) details += `Proiettili: ${s.count}, `; if (s.chains) details += `Rimbalzi: ${s.chains}, `; if (s.penetration && s.penetration < 999) details += `Perforazione: ${s.penetration}, `; weaponsHTML += `<div class="weapon-stat-details">${details.slice(0, -2) || 'Statistiche base'}</div>`; }); if (!hasWeapons) weaponsHTML += `<div>Nessuna abilitÃ  acquisita.</div>`; weaponsHTML += `</div>`; this.dom.weaponsStatsColumn.innerHTML = weaponsHTML; }
    handleEscapeKey() { const anyPopupOpen = Object.values(this.dom.popups).some(p => p.style.display === 'flex'); if (anyPopupOpen && this.state !== 'startScreen' && this.state !== 'gameOver') { this.hideAllPopups(); } else { this.togglePause(); } }
    handleInteractionKey() { if (this.menuCooldown > 0 || this.state !== 'running') return; if (Utils.getDistance(this.player, CONFIG.merchant) < CONFIG.merchant.interactionRadius) { this.showPopup('shop'); } }
    handlePointerDown(e) { if (this.state === 'gameOver' || this.state === 'startScreen') return; const rect = this.canvas.getBoundingClientRect(); const clientX = e.clientX; const clientY = e.clientY; const worldX = (clientX - rect.left) * (this.canvas.width / rect.width) + this.camera.x; const worldY = (clientY - rect.top) * (this.canvas.height / rect.height) + this.camera.y; if (this.state === 'running' && Utils.getDistance({x: worldX, y: worldY}, CONFIG.merchant) < CONFIG.merchant.interactionRadius) { this.showPopup('shop'); return; } if (e.pointerType === 'touch' && !this.joystick.active) { e.preventDefault(); this.joystick.touchId = e.pointerId; this.joystick.active = true; this.joystick.startX = clientX; this.joystick.startY = clientY; this.dom.joystick.container.style.display = 'block'; this.dom.joystick.container.style.left = `${clientX - this.dom.joystick.radius}px`; this.dom.joystick.container.style.top = `${clientY - this.dom.joystick.radius}px`; } }
    handlePointerMove(e) { if (!this.joystick.active || e.pointerId !== this.joystick.touchId) return; e.preventDefault(); let deltaX = e.clientX - this.joystick.startX; let deltaY = e.clientY - this.joystick.startY; const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); const maxDistance = this.dom.joystick.radius; if (distance > maxDistance) { deltaX = (deltaX / distance) * maxDistance; deltaY = (deltaY / distance) * maxDistance; } this.dom.joystick.stick.style.transform = `translate(${deltaX}px, ${deltaY}px)`; this.joystick.dx = deltaX / maxDistance; this.joystick.dy = deltaY / maxDistance; }
    handlePointerEnd(e) { if (this.joystick.active && e.pointerId === this.joystick.touchId) { this.joystick.active = false; this.joystick.touchId = null; this.dom.joystick.stick.style.transform = 'translate(0px, 0px)'; this.dom.joystick.container.style.display = 'none'; this.joystick.dx = 0; this.joystick.dy = 0; } }
    loadGameData() { this.permanentUpgrades = {}; Object.keys(CONFIG.permanentUpgrades).forEach(key => { this.permanentUpgrades[key] = { ...CONFIG.permanentUpgrades[key], level: 0 }; }); try { const savedData = localStorage.getItem('ballSurvivalSaveData_v3.2'); if (savedData) { const data = JSON.parse(savedData); this.totalGems = data.totalGems || 0; if (data.upgrades) { Object.keys(this.permanentUpgrades).forEach(key => { if (data.upgrades[key]) this.permanentUpgrades[key].level = data.upgrades[key].level || 0; }); } } else { this.totalGems = 0; } } catch (e) { console.error("Impossibile caricare i dati salvati:", e); this.totalGems = 0; } }
    saveGameData() { try { const saveData = { totalGems: this.totalGems, upgrades: this.permanentUpgrades }; localStorage.setItem('ballSurvivalSaveData_v3.2', JSON.stringify(saveData)); } catch (e) { console.error("Impossibile salvare i dati:", e); } }
    populateShop() { this.dom.totalGemsShop.textContent = this.totalGems; const container = this.dom.permanentUpgradeOptions; container.innerHTML = ''; for (const key in this.permanentUpgrades) { const upg = this.permanentUpgrades[key]; const cost = Math.floor(upg.baseCost * Math.pow(upg.costGrowth, upg.level)); let optionHTML = `<div class="permanent-upgrade-option"><div><div class="upgrade-title">${upg.name}</div><div class="perm-upgrade-level">Livello: ${upg.level} / ${upg.maxLevel}</div><div class="upgrade-desc">Effetto attuale: ${upg.effect(upg.level)}</div></div>`; if (upg.level < upg.maxLevel) { optionHTML += `<div><div class="perm-upgrade-cost">Costo: ${cost} ðŸ’Ž</div><button class="buy-button" data-key="${key}" ${this.totalGems < cost ? 'disabled' : ''}>Compra</button></div>`; } else { optionHTML += `<div><span style="color: #2ecc71;">MAX</span></div>`; } optionHTML += `</div>`; container.innerHTML += optionHTML; } container.querySelectorAll('.buy-button').forEach(btn => { btn.onclick = () => this.buyPermanentUpgrade(btn.dataset.key); }); }
    buyPermanentUpgrade(key) { const upg = this.permanentUpgrades[key]; const cost = Math.floor(upg.baseCost * Math.pow(upg.costGrowth, upg.level)); if (upg.level < upg.maxLevel && this.totalGems >= cost) { this.totalGems -= cost; upg.level++; this.saveGameData(); this.player.applyPermanentUpgrades(this.permanentUpgrades); this.populateShop(); } }
    applyItemEffect(item) { const itemInfo = CONFIG.itemTypes[item.type]; this.notifications.push({ text: itemInfo.desc, life: 300 }); switch (item.type) { case 'HEAL_POTION': this.player.hp = Math.min(this.player.stats.maxHp, this.player.hp + this.player.stats.maxHp * 0.5); break; case 'XP_BOMB': if(this.player.gainXP(this.player.xpNext)) this.handleLevelUp(); break; case 'INVINCIBILITY': this.player.powerUpTimers.invincibility = 600; break; case 'DAMAGE_BOOST': this.player.powerUpTimers.damageBoost = 1200; break; case 'LEGENDARY_ORB': this.player.powerUpTimers.damageBoost = 3600; this.player.powerUpTimers.invincibility = 3600; break; } }
    updateCamera() { this.camera.x = this.player.x - this.camera.width / 2; this.camera.y = this.player.y - this.camera.height / 2; this.camera.x = Math.max(0, Math.min(this.camera.x, CONFIG.world.width - this.camera.width)); this.camera.y = Math.max(0, Math.min(this.camera.y, CONFIG.world.height - this.camera.height)); }
    resizeCanvas() { const rect = this.dom.gameContainer.getBoundingClientRect(); this.canvas.width = rect.width; this.canvas.height = rect.height; this.camera.width = this.canvas.width; this.camera.height = this.canvas.height; if (this.state !== 'running') this.draw(); }
    drawOffscreenIndicators() { if(this.entities.chests.length > 0) this.drawOffscreenIndicator(this.entities.chests[0], "rgba(255, 215, 0, 0.7)", 'arrow'); this.drawOffscreenIndicator(CONFIG.merchant, "rgba(155, 89, 182, 0.8)", 'triangle'); }
    drawOffscreenIndicator(target, color, shape) { const screenX = target.x - this.camera.x; const screenY = target.y - this.camera.y; if (screenX > 0 && screenX < this.canvas.width && screenY > 0 && screenY < this.canvas.height) return; const pScreenX = this.player.x - this.camera.x; const pScreenY = this.player.y - this.camera.y; const angle = Math.atan2(screenY - pScreenY, screenX - pScreenX); const padding = 30; let arrowX = pScreenX + Math.cos(angle) * (Math.min(this.canvas.width, this.canvas.height) / 2.5); let arrowY = pScreenY + Math.sin(angle) * (Math.min(this.canvas.width, this.canvas.height) / 2.5); arrowX = Math.max(padding, Math.min(this.canvas.width - padding, arrowX)); arrowY = Math.max(padding, Math.min(this.canvas.height - padding, arrowY)); this.ctx.save(); this.ctx.translate(arrowX, arrowY); this.ctx.rotate(angle); this.ctx.fillStyle = color; this.ctx.strokeStyle = "white"; this.ctx.lineWidth = 1; this.ctx.beginPath(); if (shape === 'arrow') { this.ctx.moveTo(15, 0); this.ctx.lineTo(-15, -10); this.ctx.lineTo(-10, 0); this.ctx.lineTo(-15, 10); } else { this.ctx.moveTo(0, -10); this.ctx.lineTo(10, 10); this.ctx.lineTo(-10, 10); } this.ctx.closePath(); this.ctx.fill(); this.ctx.stroke(); this.ctx.restore(); }
    drawNotifications() { this.ctx.save(); this.ctx.textAlign = 'center'; this.ctx.font = 'bold clamp(14px, 2.5vw, 18px) "Courier New", monospace'; this.notifications.forEach((n, index) => { const opacity = n.life > 30 ? 1.0 : n.life / 30; this.ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`; this.ctx.shadowColor = "rgba(0, 0, 0, 0.7)"; this.ctx.shadowBlur = 5; this.ctx.fillText(n.text, this.canvas.width / 2, 40 + (index * 25)); }); this.ctx.restore(); }
    drawMerchant() { const m = CONFIG.merchant; this.ctx.fillStyle = '#9b59b6'; this.ctx.fillRect(m.x, m.y, m.size, m.size); this.ctx.strokeStyle = '#f1c40f'; this.ctx.lineWidth = 3; this.ctx.strokeRect(m.x, m.y, m.size, m.size); if (this.state === 'running' && Utils.getDistance(this.player, m) < m.interactionRadius) { this.ctx.font = 'bold 14px "Courier New"'; this.ctx.fillStyle = 'white'; this.ctx.textAlign = 'center'; this.ctx.fillText("[E] / Tocca", m.x + m.size / 2, m.y - 25); this.ctx.fillText("Negozio", m.x + m.size / 2, m.y - 10); } }
}
window.addEventListener('DOMContentLoaded', () => { new BallSurvivalGame('gameCanvas'); });
</script>
</body>
</html>